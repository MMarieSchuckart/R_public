# Basics of data analysis in R 
# Tutorial by Merle Schuckart (schuckart@psychologie.uni-kiel.de)
# June 2021

# ----------------------------------------------------------------
# Description of this script:

# This script will walk you through a simple 
# data analysis (reading in data, preprocessing, stats & plotting)

# Description of the data used herein:
# The data we're analyzing here are from a simple experiment 
# in which I tried to replicate the redundant 
# signals effect (RSE) in which a participant should 
# react faster to multisensory stimuli than to unisensory ones.
# All files are test data generated by me, so no worries about 
# privacy concerns here. I just added made up participant information
# and copied a few datasets so we have more data 
# (that's why some contain exactly the same RTs in all trials).

# Variables: 
# A = 1 unisensory audio-stimulus
# V = 1 unisensory visual stimulus
# AV = 1 mutisensory audio-visual stimulus

# ----------------------------------------------------------------

# 1. load packages ----

# for testing normality of distribution (KS-lilliefors-Test):
#install.packages("nortest")
library(nortest) 

# for plots:
#install.packages("ggplot2")
library(ggplot2) 


# 2. Load data and do preprocessing ----

# 2.1 set working directory (= path to the file your data are in)
# set your own path here:
setwd('/Users/merle/Desktop/simulated_data/') 
# Please notice we're always using these slashes /, 
# these ones \ don't work here.

# 2.2 Get the list of files in the directory
file_list <- list.files(pattern='.csv')

# 2.3 Loop through files to read in data

# 2.3.1
# Create empty dataframes as placeholder for 
# the df where you collect all our data & 
# one for the demographic information
df_data <- data.frame() 
df_demographics <- data.frame()

# 2.3.2 loop datasets aka participants:
for (i in 1:length(file_list)) { # for the number of files in our directory...
  
  # 2.3.2.1 Get dataframe for one participant
  subj_df <- read.csv(file_list[i], sep = ";")
  
  # 2.3.2.2 Get participant id (= VP Code)
  row_consent <-  which(subj_df$sender == "Consent") # find the row where sender == Consent
  col_id <- which(names(subj_df) == "code") # which column name is "code"?
  id <- subj_df[row_consent, col_id] # get value where column name is "code" and row name is Demographics
  
  # 2.3.2.3 Get age
  row_demogr <-  which(subj_df$sender == "Demographics") # find the row where sender == Demographics   
  col_age <- which(names(subj_df) == "age") # which column name is "age"?
  age <- subj_df[row_demogr, col_age] # get value where column name is "age" and row name is Demographics
  
  # 2.3.2.4 Get gender (this time all in one line - just to show you that you don't have to take baby steps)
  gender <- subj_df[which(subj_df$sender == "Demographics"), which(names(subj_df) == "gender")]
  
  # 2.3.2.5 Get info about exclusion criteria (again all in one line because I'm lazy, 
  # you can also do it in 3 lines if that's easier for you)
  imp_eyesight <- subj_df[which(subj_df$sender == "Demographics"), which(names(subj_df) == "impaired_eyesight")]
  imp_hearing <- subj_df[which(subj_df$sender == "Demographics"), which(names(subj_df) == "impaired_hearing")]
  drugs <- subj_df[which(subj_df$sender == "Demographics"), which(names(subj_df) == "drugs")]
  
  # 2.3.2.6 if any of the three exclusion criteria is "yes", 
  # the person should be excluded from further analysis
  # for now, we just mark them so we can exclude them later
  if ( any( c(imp_eyesight, imp_hearing, drugs) == "yes" ) ) { 
    exclude_participant <- T
  } else {
    exclude_participant <- F
  }
  
  
  # 2.3.2.7 Now get data (RTs and condition names):

  # get position of column with reaction times (durations) and condition names
  col_cond <- which(names(subj_df) == "condition")
  col_RTs <- which(names(subj_df) == "duration")
  RT_data <- subset(subj_df, sender == "reaction")[c(col_cond, col_RTs)] # get only a part of subj_df
  # RT_data is now a matrix with 2 columns, but we have to covert it to a dataframe
  RT_data <- as.data.frame(RT_data)
  
  # uncomment this line and run it to have a look at your df:
  #View(RT_data)
  
  # You can see that the column with the reaction times is still called 
  # "duration" as in the original csv file, so we rename it:
  names(RT_data) <- c("condition", "reaction_time")
  
  # exclude all trials in which the reaction time is either 
  # too short (< 100 ms) or too long (> 700 ms):
  RT_data_clean <- subset(RT_data, reaction_time >= 100 & reaction_time <= 700)
  
  # how many trials did we exclude?
  trials_excluded <- length(RT_data$reaction_time) - length(RT_data_clean$reaction_time)
  
  # 2.3.2.8 Create 2 dfs: 
  # One with demographic information & number of excluded trials, 
  # one with the RT-data, conditions and IDs.
  
  # df 1:
  # combine all information we collected about the participant in a
  # df consisting of 1 row and 8 columns 
  dem <- as.data.frame(cbind(id, age, gender, 
                             drugs, imp_eyesight, imp_hearing, 
                             exclude_participant, trials_excluded))
  # add to big df with all participants as new row, so there's 1 row for each participant
  df_demographics <- as.data.frame(rbind(df_demographics, dem))
  
  
  # df 2: 
  # create a vector that contains the subject ID, but repeat it 
  # so there's 1 value for each row in RT_data_clean:
  participant_ID <- c(rep(id, times = length(RT_data_clean$condition)))
  # append the ID vector to RT_data_clean 
  RT_data_clean <- as.data.frame(cbind(participant_ID, RT_data_clean))
  # append RT_data_clean to big df containing data from all participants
  df_data <- as.data.frame(rbind(df_data, RT_data_clean))
  
} # END loop files in directory  

# 2.3.3 clean up a bit: 
# remove everything from environment except for the things we still need
rm(list=setdiff(ls(), c("df_data", "df_demographics")))

# Uncomment this to have a look at your dataframes: 
#View(df_data)
#View(df_demographics)

# 2.3.5 Now exclude all participants who were marked before as to be excluded:
pos_excl <- which(df_demographics$exclude_participant == T)
# get their codes (in this case it's just 1 person)
id_excl <- df_demographics[pos_excl,]$id
df_data_clean <- subset(df_data, participant_ID != id_excl)

# If we now check the unique IDs left in df_data_clean, we don't see 
# the Code "LU28P" anymore. Uncomment to have a look:
# unique(df_data_clean$participant_ID)


# 3. descriptive stats ----

# Now we perform summary stats for the descriptive part of your paper:

# 3.1 Get median RT of RTs for each participant in each 
# of the 3 conditions (A, V and VA):

# aggregate data:
agg_data = aggregate(df_data_clean$reaction_time,
                     by = list(df_data_clean$participant_ID, 
                               df_data_clean$condition),
                     FUN = median)
# name new column:
names(agg_data) <- c("ID", "condition", "median_RT")


# 3.2 Get median RT and SD of RTs in each of the 3 conditions (A, V and VA):

# We can use the median RTs in agg_data to compare our groups statistically, 
# but we also need means & sds for each condition aggregated over all participants
# for a table in our paper, so create another aggregated df:

# aggregate data:
agg_conditions = aggregate(df_data_clean$reaction_time,
                     by = list(df_data_clean$condition),
                     FUN = median)

# get SD as well:
sd = aggregate(df_data_clean$reaction_time,
               by = list(df_data_clean$condition),
               FUN = sd)$x
# append to agg_conditions as additional column:
agg_conditions <- as.data.frame(cbind(agg_conditions, sd))

# correct the column names: 
names(agg_conditions) <- c("Condition", "Median RT", "SD")

# Have a look: Our hypothesis was that the RTs in the multisensory 
# condition should be a little faster than in A and V. Looks good!
# View(agg_conditions)


# 4. inferential stats ----

# 4.1 Lillifors tests
# We have a super small sample, but we 
# test the distribution anyway so you know how to do it:
lillie.test(subset(agg_data, condition == "A")$median_RT) # p-value = 0.1468, so not significant --> maybe normally distributed
lillie.test(subset(agg_data, condition == "VA")$median_RT) # p-value = 0.002617, significant --> not normally distributed
lillie.test(subset(agg_data, condition == "V")$median_RT) # p-value = 0.1001, so not significant --> maybe normally distributed

# Normality of distribution is not given anyway, 
# so no need for other checks: Use non-parametric tests!

# 4.2 Friedman Test (like ANOVA)

Sample_matrix <- matrix(c(subset(agg_data, condition == "A")$median_RT,
                          subset(agg_data, condition == "V")$median_RT,
                          subset(agg_data, condition == "VA")$median_RT),
                          ncol=3)
friedman.test(Sample_matrix) # p-value = 0.01111, so it's significant! 

# As the Friedman test was significant, we can now use post-hoc tests to 
# find out which groups are significantly different.


# 4.3 Post-hoc tests! 
# (use Wilcoxon signed-rank tests aka nonparametrical 
# t-tests for dependent groups)

# 4.3.1 Difference between V and VA: Is V > VA?
wilcox.test(subset(agg_data, condition == "V")$median_RT, # H1: is > than...
            subset(agg_data, condition == "VA")$median_RT, 
            alternative = "greater",
            paired = T, # dependent sample, so T
            exact = F)$p.value * 3 # Bonferroni-Holm correction for multiple comparisons
# p-value = 0.05025789, so no significant difference here

# If we didn't correct for multiple comparisons here, we'd 
# get a significant result (try removing the $p.value * 3 at the end 
# and run the snippet again!) but there would also be alpha-inflation so
# it's good we corrected. :-)


# 4.3.2 Difference between A and VA: Is A > VA?
wilcox.test(subset(agg_data, condition == "A")$median_RT, # H1: is > than...
            subset(agg_data, condition == "VA")$median_RT, 
            alternative = "greater",
            paired = T, # dependent sample, so T
            exact = F)$p.value * 3 # Bonferroni-Holm correction for multiple comparisons
# p-value = 0.05025789, so no significant difference here either 


# 4.3.3 Difference between A and V: probably none
# Wilcoxon-signed-rank-Test (like t-test for dependent groups)
wilcox.test(subset(agg_data, condition == "A")$median_RT, # H1: is > or < than...
            subset(agg_data, condition == "V")$median_RT, 
            alternative = "two.sided",
            paired = T, # dependent sample, so T
            exact = F)$p.value * 3 # Bonferroni-Holm correction for multiple comparisons
# not significant on an alpha level of 20%, 
# so there's probably no difference between V and A (we don't know for sure 
# tho because we just attempted to 'test' the H0 
# which is actually not possible)


# 5. Plots ----

# You can use this website to get pretty colors for your plot:
# https://www.color-hex.com/

my_plot <- ggplot(agg_data, aes(x = condition, 
                                y = median_RT, 
                                color = condition, 
                                alpha = 1)) + # alpha = opacity
           # add boxplot:
           geom_boxplot(width = 0.3, aes(alpha = 0.1)) +
           # add scatterplot:
           geom_jitter(aes(alpha = 0.5), 
                       position = position_jitter(0.1), 
                       size = 2) +
           # change axis limits, so the y axis starts at 0:
           ylim(0, 350) +
           # rename axis labels
           ylab(label = "median reaction time (ms)") +
           xlab(label = "stimulus condition") +
           # set title
           ggtitle("Hello People! \n Look at me, I'm a plot!") + # you can make a linebreak by using \n
           # set font size for axis labels:
           theme(axis.title.x = element_text(size = 14), 
                 axis.text.x = element_text(size=14),
                 axis.title.y = element_text(size = 14), 
                 axis.text.y = element_text(size=14),
                 plot.title = element_text(size=20, hjust = 0.5)) +
           # set colors manually (you can also use pre-made color 
           # palettes, e.g. from the colorbrewer package)
           scale_color_manual(values =  c("#00b159", "#00aedb", "#ffc425")) +
           # turn off legend:
           theme(legend.position = "none") + 
           # turn off lines and grey background color, 
           # so the background is white:
           theme(panel.grid.major = element_blank(), 
                 panel.grid.minor = element_blank(),
                 panel.background = element_blank(), 
                 axis.line = element_line(colour = "black")) 

# View plot
my_plot

# This is just an example, you can build more 
# or less anything you want in ggplot2. There are also a lot of cool 
# examples for plots on the internet, most of them with code you can copy 
# (check out pirateplots from the yarrr package!)


